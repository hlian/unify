module Main where

import Data.Map (Map)
import qualified Data.Map as Map
import BasePrelude hiding (TVar, insert, empty, left, right)

data Prim =
    PrimInt
  | PrimReal
  | PrimString
  deriving (Show, Eq)

-- Dumb, and practical.
data Var =
  A | B | C
  deriving (Show, Eq, Ord)

-- Our type-declaration language has ints, reals, strings, variables,
-- n-arity arrows, and lists.
data Type =
    TPrim Prim
  | TVar Var
  | TFn [Type]
  | TList Type
  deriving (Show, Eq)

-- A simple (and inefficient) graph of links from variables to types.
data Links =
  Links (Map Var Type)
  deriving (Show, Eq)

data LinksError =
    -- Unable to unify. See example 2 below.
    LinksErrorBottom Type Type
    -- A cycle occurred during unification. See example 5 below.
  | LinksErrorCycle Var Type
  deriving (Show, Eq)

empty :: Links
empty =
  Links Map.empty

follow :: Var -> Links -> [Type]
follow var links@(Links amap) =
  case Map.lookup var amap of
   Just anode@(TVar avar) ->
     anode : follow avar links
   Just anode ->
     [anode]
   Nothing ->
     []

references :: Type -> Links -> [Var]
references node links@(Links amap) =
  case node of
   TVar avar ->
     avar:(case Map.lookup avar amap of
            Just anode ->
              references anode links
            Nothing ->
              [])
   TPrim _ ->
     []
   TFn nodes ->
     mconcat ((`references` links) <$> nodes)
   TList anode ->
     references anode links

insert :: Var -> Type -> Links -> Either LinksError Links
insert var (TVar avar) links | avar == var =
  Right links
insert var node links@(Links amap) =
  if var `elem` references node links then
    Left (LinksErrorCycle var node)
  else
    Right (Links (Map.insert var node amap))

-- unify' attempts to unify the two types given an additional graph of
-- "link" edges, which represent type-equality equations found in the
-- course of unifying. It returns a new graph of links, and a list of
-- additional types that need to be unified.
unify' :: Type -> Type -> Links -> Either LinksError (Links, [(Type, Type)])
unify' node1 node2 links =
  case (node1, node2) of

   -- Two primitives of the same type unify without any additional
   -- goals. No links produced.
   (TPrim prim1, TPrim prim2)
     | prim1 == prim2 ->
       Right (links, [])

   -- Two functions of the same arity unify if all their arguments
   -- unify. No links produced.
   (TFn args1, TFn args2)
     | length args1 == length args2 ->
       Right (links, zip args1 args2)

   -- Two lists unify if their one polymorphic type unifies. No links
   -- produced.
   (TList left, TList right) ->
     Right (links, [(left, right)])

   -- If either type is a variable, see if outgoing links from said
   -- variable exist.
   (TVar var, node) ->
     case follow var links of
      -- If they do not, generate a link from said variable to the
      -- other type.
      [] -> do
        links' <- insert var node links
        return (links', [])
      -- If they do, recast the problem as unifying the type at the
      -- end of the path with the other type.
      path ->
        unify' (last path) node links
   -- Switch order to reduce code.
   (_, TVar _) ->
     unify' node2 node1 links

   -- Otherwise the two types cannot unify, as represented by the
   -- bottom type.
   _ ->
     Left (LinksErrorBottom node1 node2)

-- unify takes a list of initial goals and does a breadth-first fold
-- over the solution space of goals, in order to generate a graph of
-- links. The BFS for this solution space works as follows: each
-- vertex is a goal (a pair of types to be unified); each vertex's
-- neighbors are the goals generated by calling unify'.
--
-- It's our desire that the fold for the links graph is such that the
-- order of traversal doesn't matter, but I think the way I've done it
-- necessitates breadth-first. I don't know. Math.
unify :: [(Type, Type)] -> Links -> Either LinksError Links
unify [] links =
  Right links
unify ((m, n) : rest) links = do
  -- One step forward yields a new accumulator (links graph) and a new
  -- set of neighbors to visit.
  (links', yetMore) <- unify' m n links
  unify (rest ++ yetMore) links'

-- generalize attemps to, given a type and a graph of links, yield the
-- most general type possible by following all eligible variables.
generalize :: Links -> Type -> Type
generalize _ (TPrim primitive) =
  TPrim primitive
generalize links (TFn nodes) =
  TFn (generalize links <$> nodes)
generalize links (TList node) =
  TList (generalize links node)
generalize links (TVar name) =
  case follow name links of
   [] ->
     TVar name
   path ->
     last path

spew :: Type -> Type -> IO ()
spew left right =
  case unify [(left, right)] empty of
   Left e ->
     print e
   Right links ->
     print (generalize links left)

main :: IO ()
main = do
  -- TFn [TPrim PrimInt,TPrim PrimInt,TPrim PrimInt]
  spew ex1l ex1r
  -- LinksErrorBottom (TFn [TVar A,TPrim PrimInt,TVar B]) (TFn [TPrim PrimInt,TVar C])
  spew ex2l ex2r
  -- TFn [TVar C,TVar C,TVar C]
  spew ex3l ex3r
  -- TFn [TFn [TVar B,TVar B],TFn [TVar B,TVar B]]
  spew ex4l ex4r
  -- LinksErrorCycle B (TVar A)
  spew ex5l ex5r
  where
    ex1l = TFn [TPrim PrimInt, TPrim PrimInt, TVar A]
    ex1r = TFn [TVar A, TPrim PrimInt, TPrim PrimInt]
    ex2l = TFn [TVar A, TPrim PrimInt, TVar B]
    ex2r = TFn [TPrim PrimInt, TVar C]
    ex3l = TFn [TVar A, TVar B, TVar C]
    ex3r = TFn [TVar B, TVar C, TVar C]
    ex4l = TFn [TVar A, TVar A]
    ex4r = TFn [TFn [TVar B, TVar B], TFn [TVar B, TVar B]]
    ex5l = TFn [TVar A, TList (TVar B)]
    ex5r = TFn [TVar B, TList (TVar A)]
